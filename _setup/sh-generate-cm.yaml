apiVersion: v1
kind: ConfigMap
metadata:
  namespace: argocd
  name: sh-generate
data:
  helm: |
    #!/usr/bin/bash
    export PATH="/sh-generate:$PATH"

    # if Chart.yaml isn't empty or generate.sh doesn't exists -> exec helm
    [[ -s Chart.yaml || ! -f generate.sh ]] && exec helm "$@"

    # if not "helm template" -> exit
    [ "$1" != template ] && exit 0

    export ARGOCD_APP_NAME ARGOCD_APP_NAMESPACE KUBE_VERSION KUBE_API_VERSIONS
    ARGS=("$@")
    for ((i = 0; i < "$#"; i++)); do
      case "${ARGS[$i]}" in
      --name-template) i="$((i + 1))"; ARGOCD_APP_NAME="${ARGS[$i]}";;
      --namespace)     i="$((i + 1))"; ARGOCD_APP_NAMESPACE="${ARGS[$i]}";;
      --kube-version)  i="$((i + 1))"; KUBE_VERSION="${ARGS[$i]}";;
      --api-versions)  i="$((i + 1))"; KUBE_API_VERSIONS="${ARGS[$i]},$KUBE_API_VERSIONS";;
      esac
    done
    KUBE_API_VERSIONS="${KUBE_API_VERSIONS::-1}"

    export ARGOCD_APP_REVISION="$(git log -n1 --pretty="format:%H")"
    export ARGOCD_APP_REVISION_SHORT="$(echo "$ARGOCD_APP_REVISION" | head -c7)"
    export ARGOCD_APP_SOURCE_REPO_TOP_LEVEL="$(pwd | cut -d/ -f-4)"
    eval "$(kubectl get "applications.argoproj.io/$ARGOCD_APP_NAME" -o jsonpath='{.spec.source}' | yq '
      "export ARGOCD_APP_SOURCE_PATH=" + (.path | @sh),
      "export ARGOCD_APP_SOURCE_REPO_URL=" + (.repoURL | @sh),
      "export ARGOCD_APP_SOURCE_TARGET_REVISION=" + (.targetRevision // "HEAD" | @sh),
      .helm.parameters[] | "export ARGOCD_ENV_" + .name + "=" + (.value | @sh)
    ')"
    chmod +x generate.sh; exec ./generate.sh
